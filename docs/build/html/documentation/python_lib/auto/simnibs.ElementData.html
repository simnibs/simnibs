
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>simnibs.ElementData &#8212; SimNIBS 3.1-dev0 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="simnibs.subject2mni_coords" href="simnibs.subject2mni_coords.html" />
    <link rel="prev" title="simnibs.NodeData" href="simnibs.NodeData.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="simnibs.NodeData.html" title="Previous document">simnibs.NodeData</a>
        </li>
        <li>
          <a href="simnibs.subject2mni_coords.html" title="Next document">simnibs.subject2mni_coords</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="simnibs-elementdata">
<h1>simnibs.ElementData<a class="headerlink" href="#simnibs-elementdata" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="simnibs.ElementData">
<em class="property">class </em><code class="sig-prename descclassname">simnibs.</code><code class="sig-name descname">ElementData</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">name=''</em>, <em class="sig-param">mesh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">simnibs.msh.mesh_io.Data</span></code></p>
<p>Data (scalar, vector or tensor) defined in mesh elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>ndarray</em>) – <dl class="simple">
<dt>Value of field in elements. Should have the shape</dt><dd><ul>
<li><p>(n_elm,) or (n_elm, 1) for scalar fields</p></li>
<li><p>(n_elm, 3) for vector fields</p></li>
<li><p>(n_elm, 9) for tensors</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>field_name</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – name of field. Default: ‘’</p></li>
<li><p><strong>mesh</strong> (<em>simnibs.msh.Msh</em><em> (</em><em>optional</em><em>)</em>) – Mesh structure where the field is defined. Required for many methods</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="simnibs.ElementData.value">
<code class="sig-name descname">value</code><a class="headerlink" href="#simnibs.ElementData.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of field in elements</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.ElementData.field_name">
<code class="sig-name descname">field_name</code><a class="headerlink" href="#simnibs.ElementData.field_name" title="Permalink to this definition">¶</a></dt>
<dd><p>name of field</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.ElementData.elm_number">
<code class="sig-name descname">elm_number</code><a class="headerlink" href="#simnibs.ElementData.elm_number" title="Permalink to this definition">¶</a></dt>
<dd><p>index of elements</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.ElementData.nr">
<code class="sig-name descname">nr</code><a class="headerlink" href="#simnibs.ElementData.nr" title="Permalink to this definition">¶</a></dt>
<dd><p>number of data points</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>property</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.ElementData.nr_comp">
<code class="sig-name descname">nr_comp</code><a class="headerlink" href="#simnibs.ElementData.nr_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>number of dimensions per data point (1 for scalars, 3 for vectors)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>property</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">name=''</em>, <em class="sig-param">mesh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.__init__" title="simnibs.ElementData.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(value[, name, mesh])</p></td>
<td><p>Initialize self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.append_to_mesh" title="simnibs.ElementData.append_to_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append_to_mesh</span></code></a>(fn[, mode])</p></td>
<td><p>Appends this ElementData fields to a file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.as_nodedata" title="simnibs.ElementData.as_nodedata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_nodedata</span></code></a>()</p></td>
<td><p>Converts the current ElementData instance to NodaData For more information see the elm_data2node_data method</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.assign_triangle_values" title="simnibs.ElementData.assign_triangle_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign_triangle_values</span></code></a>()</p></td>
<td><p>In-place Assigns field value at triangle as the same as the one of the tetrahedra with a similar tag to it.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.calc_flux" title="simnibs.ElementData.calc_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_flux</span></code></a>([triangles])</p></td>
<td><p>Calculates the flux of a vectorial field</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.elm_data2node_data" title="simnibs.ElementData.elm_data2node_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">elm_data2node_data</span></code></a>()</p></td>
<td><p>Transforms an ElementData field into a NodeData field using Superconvergent patch recovery For volumetric data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.from_data_grid" title="simnibs.ElementData.from_data_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_data_grid</span></code></a>(mesh, data_grid, affine[, …])</p></td>
<td><p>Defines an ElementData field form a mesh and gridded data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.get_focality" title="simnibs.ElementData.get_focality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_focality</span></code></a>([cuttofs, peak_percentile])</p></td>
<td><p>Caluclates field focality as the area/volume of the mesh experiencing a field norm of above (cut_off% of the field peak).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.get_percentiles" title="simnibs.ElementData.get_percentiles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_percentiles</span></code></a>([percentile, roi])</p></td>
<td><p>Get percentiles of field (or field norm, if a vector field)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.interpolate_scattered" title="simnibs.ElementData.interpolate_scattered"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_scattered</span></code></a>(points[, out_fill, …])</p></td>
<td><p>Interpolates the ElementData into the points by finding the element containing the point and assigning the value in it</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.interpolate_to_grid" title="simnibs.ElementData.interpolate_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_to_grid</span></code></a>(n_voxels, affine[, …])</p></td>
<td><p>Interpolates the ElementData into a grid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.interpolate_to_surface" title="simnibs.ElementData.interpolate_to_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_to_surface</span></code></a>(surface[, out_fill])</p></td>
<td><p>Interpolates the field in the nodes of a given surface The interpolation occurs in the tetrahedra!</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.mean_field_norm" title="simnibs.ElementData.mean_field_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_field_norm</span></code></a>()</p></td>
<td><p>Calculates V*w/sum(w) Where V is the norm of the field, and w is the volume or area of the mesh where the field is defined.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.norm" title="simnibs.ElementData.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>([ord])</p></td>
<td><p>Calculate the norm of the field</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.read_hdf5_data_matrix_row" title="simnibs.ElementData.read_hdf5_data_matrix_row"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_hdf5_data_matrix_row</span></code></a>(leadfield_fn, …)</p></td>
<td><p>Reads a row of an hdf5 data matrix and store it as Data</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.summary" title="simnibs.ElementData.summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">summary</span></code></a>([percentiles, focality_cutoffs, units])</p></td>
<td><p>Creates a text summaty of the field</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.to_deformed_grid" title="simnibs.ElementData.to_deformed_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_deformed_grid</span></code></a>(warp, reference[, out, …])</p></td>
<td><p>Interpolates field to a grid and apply non-linear interpolation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.to_nifti" title="simnibs.ElementData.to_nifti"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_nifti</span></code></a>(n_voxels, affine[, fn, units, …])</p></td>
<td><p>Transforms the data in a nifti file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.view_options" title="simnibs.ElementData.view_options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_options</span></code></a>([v_range, percentile, visible, …])</p></td>
<td><p>Generates a View object with visualization opions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.write" title="simnibs.ElementData.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(fn)</p></td>
<td><p>Writes this ElementData fields to a file with field information only This file needs to be merged with a mesh for visualization</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.write_hdf5" title="simnibs.ElementData.write_hdf5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_hdf5</span></code></a>(hdf5_fn[, path])</p></td>
<td><p>Writes the field to an hdf5 file</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.elm_number" title="simnibs.ElementData.elm_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">elm_number</span></code></a></p></td>
<td><p>Element numbers (1, …, nr)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.indexing_nr" title="simnibs.ElementData.indexing_nr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indexing_nr</span></code></a></p></td>
<td><p>Same as elm_number</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.nr" title="simnibs.ElementData.nr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nr</span></code></a></p></td>
<td><p>Number of data entries</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.ElementData.nr_comp" title="simnibs.ElementData.nr_comp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nr_comp</span></code></a></p></td>
<td><p>Number of field components</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.ElementData.type" title="simnibs.ElementData.type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code></a></p></td>
<td><p>NodeData of ElementData</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="simnibs.ElementData.append_to_mesh">
<code class="sig-name descname">append_to_mesh</code><span class="sig-paren">(</span><em class="sig-param">fn</em>, <em class="sig-param">mode='binary'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.append_to_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends this ElementData fields to a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<em>str</em>) – file name</p></li>
<li><p><strong>mode</strong> (<em>binary</em><em> or </em><em>ascii</em>) – mode in which to write</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.as_nodedata">
<code class="sig-name descname">as_nodedata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.as_nodedata" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the current ElementData instance to NodaData
For more information see the elm_data2node_data method</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.assign_triangle_values">
<code class="sig-name descname">assign_triangle_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.assign_triangle_values" title="Permalink to this definition">¶</a></dt>
<dd><p>In-place Assigns field value at triangle as the same as the one of the tetrahedra with
a similar tag to it.</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.calc_flux">
<code class="sig-name descname">calc_flux</code><span class="sig-paren">(</span><em class="sig-param">triangles=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.calc_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux of a vectorial field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>triangles</strong> (<em>ndarray of ints</em><em> (</em><em>optional</em><em>)</em>) – Triangles where the flux should be calculated. Default: All</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>flux</strong> – total field crossing the surface</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.elm_data2node_data">
<code class="sig-name descname">elm_data2node_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.elm_data2node_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms an ElementData field into a NodeData field using Superconvergent
patch recovery
For volumetric data. Will not work well for discontinuous fields (like E, if
several tissues are used)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Structure with NodeData</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="simnibs.NodeData.html#simnibs.NodeData" title="simnibs.NodeData">simnibs.NodeData</a></p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Zienkiewicz, Olgierd Cecil, and Jian
Zhong Zhu. “The superconvergent patch recovery and a posteriori error
estimates. Part 1: The recovery technique.” International Journal for
Numerical Methods in Engineering 33.7 (1992): 1331-1364.</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">elm_number</code></dt>
<dd><p>Element numbers (1, …, nr)</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.from_data_grid">
<em class="property">classmethod </em><code class="sig-name descname">from_data_grid</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">data_grid</em>, <em class="sig-param">affine</em>, <em class="sig-param">field_name=''</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.from_data_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines an ElementData field form a mesh and gridded data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="simnibs.Msh.html#simnibs.Msh" title="simnibs.Msh"><em>Msh</em></a><em>(</em><em>)</em>) – Mesh structure where the field is to be interpolated</p></li>
<li><p><strong>data_grid</strong> (<em>ndarray</em>) – Array of 3 or 4 dimensions with data</p></li>
<li><p><strong>affine</strong> (<em>4x4 ndarray</em>) – Array describing the affine transformation from the data grid to the mesh
space</p></li>
<li><p><strong>kwargs</strong> (<em>see the scipy.ndimage.map_coordinates documentation</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.get_focality">
<code class="sig-name descname">get_focality</code><span class="sig-paren">(</span><em class="sig-param">cuttofs=[50, 70], peak_percentile=99.9</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.get_focality" title="Permalink to this definition">¶</a></dt>
<dd><p>Caluclates field focality as the area/volume of the mesh experiencing a field
norm of above (cut_off% of the field peak). peak_percentile gives what is the
field peak</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cuttofs</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Percentage of the peak value for the cut_off, between 0 and 100. Default: [50, 70]</p></li>
<li><p><strong>peak_percentile</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Percentile to be used to calculate peak value. Default: 99.9</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>focality</strong> – Area/volume exceeding the cuttof of the peak value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.get_percentiles">
<code class="sig-name descname">get_percentiles</code><span class="sig-paren">(</span><em class="sig-param">percentile=[99.9], roi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.get_percentiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get percentiles of field (or field norm, if a vector field)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>percentile</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Percentiles of interest, between 0 and 100. Defaut: 99.9</p></li>
<li><p><strong>roi</strong> (<em>ndarray</em><em> (</em><em>optinal</em><em>)</em>) – Region of interest in terms of element/node indices. Default: the whole mesh</p></li>
<li><p><strong>Returnts</strong> – </p></li>
<li><p><strong>----------</strong> – </p></li>
<li><p><strong>f_p</strong> (<em>ndarray</em>) – Field at the given percentiles</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.indexing_nr">
<em class="property">property </em><code class="sig-name descname">indexing_nr</code><a class="headerlink" href="#simnibs.ElementData.indexing_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as elm_number</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.interpolate_scattered">
<code class="sig-name descname">interpolate_scattered</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">out_fill=nan</em>, <em class="sig-param">method='linear'</em>, <em class="sig-param">continuous=False</em>, <em class="sig-param">squeeze=True</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.interpolate_scattered" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates the ElementData into the points by finding the element
containing the point and assigning the value in it</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>Nx3 ndarray</em>) – List of points where we want to interpolate</p></li>
<li><p><strong>out_fill</strong> (<em>float</em>) – Value to be goven to points outside the volume, if ‘nearest’ assigns the
nearest value (default: NaN)</p></li>
<li><p><strong>method</strong> (<em>{'assign'</em><em> or </em><em>'linear'}</em><em> (</em><em>Optional</em><em>)</em>) – If ‘assign’, gives to each voxel the value of the element that contains
it. If linear, first assign fields to nodes, and then perform
baricentric interpolatiom. Default: linear</p></li>
<li><p><strong>continuous</strong> (<em>bool</em>) – Wether fields is continuous across tissue boundaries. Changes the
behaviour of the function only if method == ‘linear’. Default: False</p></li>
<li><p><strong>squeeze</strong> (<em>bool</em>) – Wether to squeeze the output. Default: True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>f</strong> – Value of function in the points</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.interpolate_to_grid">
<code class="sig-name descname">interpolate_to_grid</code><span class="sig-paren">(</span><em class="sig-param">n_voxels</em>, <em class="sig-param">affine</em>, <em class="sig-param">method='linear'</em>, <em class="sig-param">continuous=False</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.interpolate_to_grid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Interpolates the ElementData into a grid.</dt><dd><p>finds which tetrahedra contais the given voxel and
assign the value of the tetrahedra to the voxel.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_voxels</strong> (<em>list</em><em> or </em><em>tuple</em>) – number of voxels in x, y, and z directions</p></li>
<li><p><strong>affine</strong> (<em>ndarray</em>) – A 4x4 matrix specifying the transformation from voxels to xyz</p></li>
<li><p><strong>method</strong> (<em>{'assign'</em><em> or </em><em>'linear'}</em><em> (</em><em>Optional</em><em>)</em>) – If ‘assign’, gives to each voxel the value of the element that contains
it. If linear, first assign fields to nodes, and then perform
baricentric interpolatiom. Default: linear</p></li>
<li><p><strong>continuous</strong> (<em>bool</em>) – Wether fields is continuous across tissue boundaries. Changes the
behaviour of the function only if method == ‘linear’. Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>image</strong> – An (n_voxels[0], n_voxels[1], n_voxels[2], nr_comp) matrix with
interpolated values. If nr_comp == 1, the last dimension is squeezed out</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.interpolate_to_surface">
<code class="sig-name descname">interpolate_to_surface</code><span class="sig-paren">(</span><em class="sig-param">surface</em>, <em class="sig-param">out_fill='nearest'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.interpolate_to_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates the field in the nodes of a given surface
The interpolation occurs in the tetrahedra!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface</strong> (<a class="reference internal" href="simnibs.Msh.html#simnibs.Msh" title="simnibs.Msh"><em>Msh</em></a>) – Mesh structure with triangles only</p></li>
<li><p><strong>out_fill</strong> (<em>float</em><em> or </em><em>'nearest'</em><em> (</em><em>optional</em><em>)</em>) – Value to be assigned to the points in the surface outside the volume.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>node_data</strong> – Node data structure with the interpolated field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="simnibs.NodeData.html#simnibs.NodeData" title="simnibs.NodeData">NodeData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.mean_field_norm">
<code class="sig-name descname">mean_field_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.mean_field_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates V*w/sum(w)
Where V is the norm of the field, and w is the volume or area of the mesh where
the field is defined. This can be used as a focality metric. It should give out
small values when the field is focal and</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>eff_area</strong> – Area or volume of mesh, weighted by the field</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">ord=2</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the norm of the field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ord</strong> (<em>float</em>) – Order of norm. Default: 2 (euclidian norm)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>norm</strong> – NodeData field with the norm the field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="simnibs.NodeData.html#simnibs.NodeData" title="simnibs.NodeData">NodeData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">nr</code></dt>
<dd><p>Number of data entries</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">nr_comp</code></dt>
<dd><p>Number of field components</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.read_hdf5_data_matrix_row">
<em class="property">classmethod </em><code class="sig-name descname">read_hdf5_data_matrix_row</code><span class="sig-paren">(</span><em class="sig-param">leadfield_fn</em>, <em class="sig-param">field_name</em>, <em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.read_hdf5_data_matrix_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a row of an hdf5 data matrix and store it as Data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>leadfield_fn</strong> (<em>str</em>) – Name of file with leadfield</p></li>
<li><p><strong>field_name</strong> (<em>str</em>) – name of field</p></li>
<li><p><strong>row</strong> (<em>int</em>) – number of the row to be read</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>data</strong> – instance with the fields</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Data()</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><em class="sig-param">percentiles=(99.9</em>, <em class="sig-param">99</em>, <em class="sig-param">95)</em>, <em class="sig-param">focality_cutoffs=(75</em>, <em class="sig-param">50)</em>, <em class="sig-param">units=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a text summaty of the field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>percentiles</strong> (<em>ndarray</em><em> (</em><em>optinal</em><em>)</em>) – Field percentiles to be printed. Default: (99.9, 99, 95)</p></li>
<li><p><strong>focality_cutoffs</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Cuttofs for focality calculations. Default: (75, 50)</p></li>
<li><p><strong>units</strong> (<em>str</em><em> or </em><em>None</em>) – Name of field units or automatically determine from name</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.to_deformed_grid">
<code class="sig-name descname">to_deformed_grid</code><span class="sig-paren">(</span><em class="sig-param">warp</em>, <em class="sig-param">reference</em>, <em class="sig-param">out=None</em>, <em class="sig-param">out_original=None</em>, <em class="sig-param">tags=None</em>, <em class="sig-param">order=1</em>, <em class="sig-param">method='linear'</em>, <em class="sig-param">continuous=False</em>, <em class="sig-param">inverse_warp=None</em>, <em class="sig-param">reference_original=None</em>, <em class="sig-param">binary=False</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.to_deformed_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates field to a grid and apply non-linear interpolation</p>
<p>We first interpolate to a grid and then apply the transformation in order to
avoid problems from deformed triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>warp</strong> (<em>str</em>) – Name of file with the transformation. Can either be a nifti file
where each voxel corresponds to coordinates (x, y, z) in the original space
or an affine transformation defined from the target space to the original
space. In the later case, the name must finish in “.mat”, and it will be read
with the numpy loadtxt file</p></li>
<li><p><strong>ref</strong> (<em>str</em>) – Name of reference file. The output will be in the same space
as the reference (same affine transfomation and same dimensions)</p></li>
<li><p><strong>out</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – If not None, the result will be written to this file as a nifti</p></li>
<li><p><strong>out_original</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – If not None, the volume in the original grid be written to this file as a nifti</p></li>
<li><p><strong>tags</strong> (<em>list</em><em> (</em><em>optional</em><em>)</em>) – Mesh tags to be transformed. Defaut: transform the entire mesh</p></li>
<li><p><strong>order</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Interpolation order to be used. Default: 1</p></li>
<li><p><strong>method</strong> (<em>{'assign'</em><em> or </em><em>'linear'}</em><em> (</em><em>Optional</em><em>)</em>) – Method for gridding the data.
If ‘assign’, gives to each voxel the value of the element that contains
it. If linear, first assign fields to nodes, and then perform
baricentric interpolatiom. Only for ElementData input. Default: linear</p></li>
<li><p><strong>continuous</strong> (<em>bool</em>) – Wether fields is continuous across tissue boundaries. Changes the
behaviour of the function only if method == ‘linear’. Default: False</p></li>
<li><p><strong>inverse_warp</strong> (<em>str</em>) – Name of nifti file with inverse the transformation. Used to rotate vectors to the
target space in the case of non-liner transformations. If the transformation is
linear, the inverse matrix is used.</p></li>
<li><p><strong>reference_original</strong> (<em>str</em>) – Name of nifti file with reference in the original space. Used to determine
the dimensions and affine transformation for the initial griding</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>img</strong> – Nibabel image object with tranformed field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nibabel.Nifti1Pair</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.to_nifti">
<code class="sig-name descname">to_nifti</code><span class="sig-paren">(</span><em class="sig-param">n_voxels</em>, <em class="sig-param">affine</em>, <em class="sig-param">fn=None</em>, <em class="sig-param">units='mm'</em>, <em class="sig-param">qform=None</em>, <em class="sig-param">method='linear'</em>, <em class="sig-param">continuous=False</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.to_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the data in a nifti file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_voxels</strong> (<em>list of ints</em>) – Number of vexels in each dimension</p></li>
<li><p><strong>affine</strong> (<em>4x4 ndarray</em>) – Transformation of voxel space into xyz. This sets the sform</p></li>
<li><p><strong>fn</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – String with file name to be used, if the result is to be saved</p></li>
<li><p><strong>units</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – Units to be set in the NifTI header. Default: mm</p></li>
<li><p><strong>qform</strong> (<em>4x4 ndarray</em><em> (</em><em>optional</em><em>)</em>) – Header qform. Default: set the same as the affine</p></li>
<li><p><strong>method</strong> (<em>{'assign'</em><em> or </em><em>'linear'}</em><em> (</em><em>Optional</em><em>)</em>) – If ‘assign’, gives to each voxel the value of the element that contains
it. If linear, first assign fields to nodes, and then perform
baricentric interpolatiom. Only for ElementData input. Default: linear</p></li>
<li><p><strong>continuous</strong> (<em>bool</em>) – Wether fields is continuous across tissue boundaries. Changes the
behaviour of the function only if method == ‘linear’. Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>img</strong> – Image object with the field interpolated in the voxels</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nibabel.Nifti1Pair</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.type">
<em class="property">property </em><code class="sig-name descname">type</code><a class="headerlink" href="#simnibs.ElementData.type" title="Permalink to this definition">¶</a></dt>
<dd><p>NodeData of ElementData</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.view_options">
<code class="sig-name descname">view_options</code><span class="sig-paren">(</span><em class="sig-param">v_range='auto'</em>, <em class="sig-param">percentile=False</em>, <em class="sig-param">visible=True</em>, <em class="sig-param">visible_tags=None</em>, <em class="sig-param">saturate=True</em>, <em class="sig-param">idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.view_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a View object with visualization opions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_range</strong> (<em>[</em><em>min</em><em>, </em><em>max</em><em>] or </em><em>'auto'</em><em> (</em><em>optional</em><em>)</em>) – Range of the values to be displayed. Defaut: will automatically try to find a
good range (0.1 - 99.9% percentile for positive or vector data, symetrical
for two-sided data)</p></li>
<li><p><strong>percentile</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether the values in v_range arre given in percentile (between 0 and 100).
Default: False</p></li>
<li><p><strong>visible</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether to turn on visualization of this field. Default: True</p></li>
<li><p><strong>visible_tags</strong> (<em>list</em><em> (</em><em>optional</em><em>)</em>) – List of tags to be visible. Will also be used to calulate field ranges in
‘auto’ mode or if percentile=True. Default: all tags</p></li>
<li><p><strong>saturate</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether to saturate values. Default: true</p></li>
<li><p><strong>idx</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Index of this field in the mesh</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>view</strong> – view object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>gmsh_visualization.View</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes this ElementData fields to a file with field information only
This file needs to be merged with a mesh for visualization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<em>str</em>) – file name</p></li>
<li><p><strong>mode</strong> (<em>binary</em><em> or </em><em>ascii</em>) – mode in which to write</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.ElementData.write_hdf5">
<code class="sig-name descname">write_hdf5</code><span class="sig-paren">(</span><em class="sig-param">hdf5_fn</em>, <em class="sig-param">path='./'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.ElementData.write_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the field to an hdf5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdf5_fn</strong> (<em>str</em>) – file name of hdf5 file</p></li>
<li><p><strong>path</strong> (<em>str</em>) – path in the hdf5 file where the field should be saved</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="simnibs.NodeData.html" title="Previous document">simnibs.NodeData</a>
        </li>
        <li>
          <a href="simnibs.subject2mni_coords.html" title="Next document">simnibs.subject2mni_coords</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../installation/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dataset.html">Example Dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../gui.html">Graphical User Interface Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../command_line/command_line.html">Command Line Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sim_struct/sim_struct.html">Simulation Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../opt_struct/opt_struct.html">Optimization Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../output_files.html">Output Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../file_formats.html">File Formats in SimNIBS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coordinates.html">Coordinates in SimNIBS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../conductivity.html">Standard Conductivity Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coils.html">Coil Models Included in SimNIBS</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../python_lib.html">Python Library Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributors.html">Contributors and Funding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../documentation.html">Documentation</a><ul>
  <li><a href="../python_lib.html">Python Library Documentation</a><ul>
      <li>Previous: <a href="simnibs.NodeData.html" title="previous chapter">simnibs.NodeData</a></li>
      <li>Next: <a href="simnibs.subject2mni_coords.html" title="next chapter">simnibs.subject2mni_coords</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, SimNIBS Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/documentation/python_lib/auto/simnibs.ElementData.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>